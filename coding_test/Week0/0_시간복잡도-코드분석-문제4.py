# n개의 원소를 가진 데이터 컬렉션에서 특정 값 target이 존재하는지 확인하는 in 연산을 수행하려고 한다. 
# list와 set 자료구조를 사용할 때의 시간 복잡도를 빅오(Big-O) 표기법으로 각각 서술하고,
# 왜 성능 차이가 발생하는지 각 자료구조의 내부 동작 원리와 연관 지어 설명.

# 1. target in my_list (단, my_list는 n개의 원소를 가진 리스트)
# list 자료구조에서 in 연산은 선형 탐색(linear search)을 수행.
# 이는 리스트의 처음부터 끝까지 각 원소를 하나씩 비교하여 target이 존재하는지 확인하는 방식.
# 최악의 경우 리스트의 모든 원소를 확인해야 하므로, 시간 복잡도는 O(n).
# 내부적으로 리스트는 배열(array)로 구현되어 있어, 각 원소에 접근하는 데는 O(1)의 시간이 걸리지만,
# 전체 리스트를 순회해야 하므로 전체 연산은 O(n)이 됨.

# 2. target in my_set (단, my_set은 n개의 원소를 가진 세트)
# set 자료구조에서 in 연산은 해시 테이블(hash table)을 사용.
# 해시 테이블은 각 원소를 해시 함수(hash function)를 통해 고유한 인덱스로 매핑하여 저장.
# 따라서 target이 존재하는지 확인할 때는 해시 함수를 사용하여 해당 인덱스를 계산하고,
# 그 위치에 원소가 있는지 확인하면 됨.
# 이 과정은 평균적으로 O(1)의 시간이 걸리므로, set에서의 in 연산의 시간 복잡도는 O(1)임.
# 단, 최악의 경우(예: 해시 충돌이 많이 발생하는 경우)에는 O(n)이 될 수 있지만,
# 일반적으로는 매우 드물게 발생함.
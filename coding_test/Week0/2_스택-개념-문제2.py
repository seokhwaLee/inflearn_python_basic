# 문제2
# 재귀 함수는 자기 자신을 반복적으로 호출합니다. 
# 재귀 함수가 호출될 때, 호출 스택은 재귀의 각 단계별 상태(매개변수, 지역 변수 등)를 어떻게 저장하고 복원하여 
# LIFO 원리에 따라 프로그램의 흐름을 관리하는지 설명하세요. 
# 팩토리얼 계산과 같은 간단한 재귀 함수를 예시로 들어 구체적으로 서술하세요.

# 답변:
# 재귀 함수가 호출될 때, 호출 스택은 각 재귀 호출의 실행 컨텍스트를 저장한다.
# 예를 들어, 팩토리얼을 계산하는 재귀 함수가 있다고 가정한다.
# 팩토리얼 함수는 다음과 같이 정의될 수 있다:
# ```python
# def factorial(n):
#     if n == 0:
#         return 1
#     else:
#         return n * factorial(n - 1)
# ```
# 이 함수가 factorial(3)을 호출하면, 호출 스택에는 다음과 같은 순서로 실행 컨텍스트가 쌓인다(Push):
# factorial(3) -> 3 * factorial(2) -> 3 * (2 * factorial(1)) -> 3 * (2 * (1 * factorial(0))) -> 3 * (2 * (1 * 1)) = 6
# 각 호출마다 n의 값이 저장된 실행 컨텍스트가 호출 스택에 쌓인다.
# 이제 factorial(0)의 실행이 완료되면, 호출 스택에서 factorial(0)의 실행 컨텍스트가 제거된다(Pop)되고, 1이 반환된다.
# 그 다음, factorial(1)의 실행이 완료되면, 호출 스택에서 factorial(1)의 실행 컨텍스트가 제거된다(Pop)되고, 1 * 1 = 1이 반환된다.
# 이어서, factorial(2)의 실행이 완료되면, 호출 스택에서 factorial(2)의 실행 컨텍스트가 제거된다(Pop)되고, 2 * 1 = 2가 반환된다.
# 마지막으로, factorial(3)의 실행이 완료되면, 호출 스택에서 factorial(3)의 실행 컨텍스트가 제거된다(Pop)되고, 3 * 2 = 6이 반환된다.
# 이 과정에서 호출 스택은 LIFO(Last-In, First-Out) 원리로 동작한다.
# 가장 마지막에 호출된 재귀 함수가 가장 먼저 실행을 완료하고 스택에서 제거되기 때문이다.
# 이러한 LIFO 구조는 재귀 함수의 각 단계별 상태를 정확하게 복원하고 관리할 수 있게 해준다.

# 문제3
# '짝이 맞는 괄호' 문제를 해결할 때 스택이 효과적인 이유는 무엇인가요? 
# 스택의 LIFO(Last-In, First-Out) 원리가 괄호의 '중첩(nested)' 구조, 
# 즉 '가장 안쪽에서 열린 괄호가 가장 먼저 닫혀야 한다'는 규칙을 어떻게 자연스럽게 처리할 수 있는지 그 핵심 원리를 논리적으로 설명하세요.

# 답변:
# '짝이 맞는 괄호' 문제를 해결할 때 스택이 효과적인 이유는 
# 스택의 LIFO(Last-In, First-Out) 원리가 괄호의 중첩 구조를 자연스럽게 처리할 수 있기 때문이다.
# 괄호는 중첩 구조를 가지며, 가장 안쪽에서 열린 괄호가 가장 먼저 닫혀야 한다는 규칙이 있다.
# 스택은 마지막에 추가된 요소가 가장 먼저 제거되는 특성을 가지고 있기 때문에,
# 열린 괄호를 스택에 추가(push)하고, 닫힌 괄호가 나타날 때마다 스택에서 가장 최근에 추가된 열린 괄호를 제거(pop)함으로써
# 괄호의 짝을 올바르게 맞출 수 있다.
# 예를 들어, 문자열 "{()}"를 처리할 때,
# '{'가 나타나면 스택에 추가되고, 다음으로 '('가 나타나면 다시 스택에 추가된다.
# 이제 ')'가 나타나면, 스택에서 가장 최근에 추가된 '('를 제거하여 짝을 맞춘다.
# 마지막으로 '}'가 나타나면, 스택에서 '{'를 제거하여 짝을 맞춘다.
# 이 과정에서 스택은 열린 괄호의 순서를 기억하고, 닫힌 괄호가 나타날 때마다 올바른 짝을 찾아 제거함으로써
# 괄호의 중첩 구조를 효과적으로 관리할 수 있다.
# 따라서 스택의 LIFO 원리는 괄호의 짝 맞추기 문제를 해결하는 데 매우 적합하다.

# ```python
# def is_balanced_parentheses(s):
#     stack = []
#     opening = "({["
#     closing = ")}]"
#     matches = {')': '(', '}': '{', ']': '['}
#
#     for char in s:
#         if char in opening:
#             stack.append(char)
#         elif char in closing:
#             if not stack or stack[-1] != matches[char]:
#                 return False
#             stack.pop()
#     return len(stack) == 0
# # 테스트 예시
# print(is_balanced_parentheses("{()}"))  # 출력: True
# print(is_balanced_parentheses("{(})"))  # 출력: False
# ```
# 이 예시 코드에서 스택을 사용하여 괄호의 짝이 맞는지 확인하는 과정을 구현하고 있다.

# [문제 1] 호출 스택(Call Stack)과 LIFO 원리
---
Q. 함수 A -> B -> C 순서로 호출될 때, 스택에는 어떤 일이 일어나나요?
함수 호출은 '하던 일을 잠시 멈추고, 새로운 일을 처리한 뒤, 다시 돌아오는 과정'입니다. 
컴퓨터는 이 과정을 기억하기 위해 호출 스택(Call Stack)이라는 메모리 공간을 사용합니다.

1. 스택에 쌓이는 과정 (Push)
가장 먼저 실행된 함수부터 순서대로 스택의 바닥에서부터 위로 쌓입니다. 이를 Push라고 합니다.
Main 실행: 프로그램이 시작되면 Main 함수에 대한 정보가 스택에 가장 먼저 쌓입니다.
A 호출: Main이 A를 호출하면, Main은 잠시 멈추고 A의 실행 정보(매개변수, 지역 변수, 돌아갈 주소)가 담긴 스택 프레임(Stack Frame)이 Main 위에 쌓입니다.
B 호출: A가 실행되다가 B를 호출하면, A 위에 B의 스택 프레임이 쌓입니다.
C 호출: B가 실행되다가 C를 호출하면, B 위에 C의 스택 프레임이 쌓입니다.
최종 스택 상태: [Main] (바닥) → [A] → [B] → [C] (꼭대기)

2. 스택에서 해제되는 과정 (Pop)
함수의 실행이 끝나면(Return), 해당 스택 프레임은 스택에서 제거됩니다. 이를 Pop이라고 합니다. 제거되는 순서는 쌓인 순서의 반대입니다.
C 종료: C가 가장 먼저 할 일을 마칩니다. 스택의 맨 위에 있는 C가 제거(Pop)되고, 제어권은 B로 돌아갑니다.
B 종료: B가 남은 작업을 마치면 제거되고, 제어권은 A로 돌아갑니다.
A 종료: A가 작업을 마치면 제거되고, 제어권은 Main으로 돌아갑니다.
Main 종료: 프로그램이 완전히 종료되면 스택이 비워집니다.

---
Q. 왜 LIFO(Last-In, First-Out) 원리로 동작하나요?
'나중에 시작한 일(Last-In)을 먼저 끝내야(First-Out), 이전에 하던 일을 마칠 수 있기 때문'입니다.

C가 끝나지 않으면 B는 작업을 완료할 수 없습니다.
B가 끝나지 않으면 A는 작업을 완료할 수 없습니다.
따라서 가장 최근에 호출된 함수(Last-In)가 가장 먼저 실행을 마치고 사라져야(First-Out) 프로그램의 흐름이 끊기지 않고 원래의 호출 지점으로 되돌아갈 수 있습니다.


# [문제 2] 재귀 함수와 호출 스택의 상태 관리
Q. 재귀 함수는 호출 스택에서 어떻게 관리되나요?
재귀 함수라고 해서 특별한 원리가 적용되는 것은 아닙니다. '자기 자신을 호출한다'는 점만 다를 뿐, 컴퓨터 입장에서는 매번 새로운 함수를 호출하는 것과 똑같이 처리합니다.

예시: 팩토리얼 계산 (Factorial(3))
Factorial(n)이 n * Factorial(n-1)을 반환한다고 가정해 봅시다.

1단계: 호출과 상태 저장 (Push)

호출 1: Factorial(3) 호출.
스택 프레임 생성: { n: 3 } 저장.
3 * Factorial(2)를 계산해야 하는데, Factorial(2)의 값을 모르므로 대기.
호출 2: Factorial(2) 호출.
스택 프레임 생성: { n: 2 } 저장. (이전 n=3과는 별개의 공간)
2 * Factorial(1)을 계산하기 위해 대기.
호출 3: Factorial(1) 호출.
스택 프레임 생성: { n: 1 } 저장.
기저 조건(Base Case) 도달: 더 이상 호출하지 않고 1을 반환.

2단계: 반환과 복원 (Pop)
반환 1: Factorial(1)이 1을 반환하고 스택에서 Pop.
복원 1: Factorial(2) 프레임으로 돌아옴.
저장되어 있던 { n: 2 }를 다시 꺼냄.
계산 수행: 2 * 1 = 2. 결과값 2를 반환하고 스택에서 Pop.
복원 2: Factorial(3) 프레임으로 돌아옴.
저장되어 있던 { n: 3 }을 다시 꺼냄.
계산 수행: 3 * 2 = 6. 최종 결과 6을 반환하고 스택에서 Pop.

핵심 원리
호출 스택은 각 재귀 단계마다 독립적인 메모리 공간(스택 프레임)을 할당합니다. 
이 덕분에 서로 다른 단계의 변수 n이 섞이지 않고, LIFO 원리에 따라 '가장 깊은 단계의 계산'부터 차례대로 해결하며 거슬러 올라올 수 있습니다.

# [문제 3] 짝이 맞는 괄호 문제와 스택의 효용성
Q. 왜 괄호 문제 해결에 스택이 효과적인가요?
괄호 구조의 핵심은 '중첩(Nested)'과 '대칭성'입니다.
예시: ( ( ) )
이 구조에서 괄호가 닫히는 규칙을 보면, "가장 나중에 열린 괄호가 가장 먼저 닫혀야 한다"는 것을 알 수 있습니다.

가장 바깥쪽 ( 열림 (첫 번째)
안쪽 ( 열림 (두 번째) → 이 녀석이 먼저 닫혀야 함
안쪽 ) 닫힘 → 두 번째 괄호와 짝
바깥쪽 ) 닫힘 → 첫 번째 괄호와 짝
---
Q. LIFO 원리가 이를 어떻게 처리하나요?
스택의 LIFO(Last-In, First-Out) 속성은 "가장 최근에 들어온 것부터 처리한다"는 뜻입니다. 
이는 "가장 안쪽 괄호부터 처리한다"는 괄호의 논리와 완벽하게 일치합니다.

처리 과정의 논리
여는 괄호 (를 만나면: 아직 짝을 못 찾았으므로 스택에 넣습니다(Push). 즉, "짝을 기다리는 대기열"에 가장 최근 것으로 등록합니다.
닫는 괄호 )를 만나면: 누구와 짝을 이뤄야 할까요? 바로 가장 최근에 열렸던 괄호입니다.
짝 맞추기: 스택에서 하나를 꺼냅니다(Pop). 스택의 특성상 방금 넣은(가장 안쪽의) 여는 괄호가 나옵니다. 이것이 현재의 닫는 괄호와 짝이 됩니다.

결론
만약 스택(LIFO)이 아니라 큐(FIFO, 선입선출)를 사용한다면, 가장 먼저 열린 바깥쪽 괄호가 가장 안쪽의 닫는 괄호와 짝지어지게 되어 논리적 오류가 발생합니다.
따라서 "가장 최근의 상태를 기억하고 있다가, 짝이 나타나면 즉시 해소하는" 스택의 동작 방식은 중첩된 괄호 구조를 검증하는 데 가장 자연스럽고 강력한 도구가 됩니다.
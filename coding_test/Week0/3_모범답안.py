# [문제 1] 선형 큐의 한계와 원형 큐(Circular Queue)
Q. 선형 큐에서 Dequeue 반복 시 발생하는 메모리 비효율성 문제는 무엇인가요?
이 현상은 '가짜 오버플로우(False Overflow)' 또는 '메모리 단편화/낭비'라고 부릅니다.

1. 문제 상황 (선형 큐의 구조적 결함)
배열로 구현된 선형 큐(Linear Queue)는 데이터가 나가는 앞쪽(front)과 데이터가 들어오는 뒤쪽(rear)이 한 방향으로만 이동합니다.
Dequeue 연산을 수행하면 front 포인터가 뒤로 이동합니다.
이때, front 앞쪽에 있던 공간은 데이터가 빠져나가 비어 있음에도 불구하고, 포인터가 이미 지나갔기 때문에 다시 사용할 수 없는 '죽은 공간(Dead Space)'이 됩니다.
큐의 뒤쪽 공간이 꽉 차면, 앞쪽에 빈 공간이 있어도 더 이상 데이터를 넣을 수 없는 '가짜 오버플로우' 상태가 발생합니다.

Q. 이를 해결하기 위한 개선된 형태와 동작 원리는 무엇인가요?
이 문제를 해결하기 위해 고안된 자료구조가 바로 '원형 큐(Circular Queue)'입니다.

1. 개선된 형태: 원형 큐
물리적으로는 선형인 배열을 논리적으로 '처음과 끝이 연결된 고리 형태'로 간주하여 사용하는 방식입니다. 
배열의 마지막 인덱스에 도달하면 다시 0번 인덱스로 돌아가도록 만듭니다.

2. 메모리 재사용의 동작 원리 (모듈러 연산)
원형 큐의 핵심은 나머지 연산(Modulo, %)을 활용하여 인덱스를 순환시키는 것입니다.
원리: 다음 인덱스 = (현재 인덱스 + 1) % 배열의 크기
동작 과정:
데이터를 삽입(Enqueue)할 때 rear 포인터를 증가시킵니다.
만약 rear가 배열의 끝(N-1)에 도달했다면, 다음 위치는 N이 아니라 0이 됩니다.
이렇게 하면 rear가 다시 배열의 앞부분으로 돌아와, Dequeue로 인해 비워진 앞쪽의 유휴 공간에 새로운 데이터를 채워 넣을 수 있습니다.
결론: 원형 큐는 배열의 요소를 물리적으로 이동시키지 않고도 인덱스 계산만으로 앞쪽의 빈 공간을 재활용하므로, 메모리 낭비가 없으며 삽입/삭제 연산의 시간 복잡도를 항상 O(1)로 유지합니다.

# [문제 2] 요세푸스 문제(Josephus Problem)와 큐의 활용
Q. 이 문제 해결에 가장 적합한 자료구조는 무엇이며, 그 이유는 무엇인가요?
가장 적합한 자료구조는 '큐(Queue)'입니다.

이유:
요세푸스 문제의 핵심은 '원형으로 앉아 있다'는 순환 구조와 '순서대로 건너뛰며 제거한다'는 순차적 처리입니다.
큐의 FIFO(선입선출) 특성은 줄을 서서 차례를 기다리는 구조를 완벽하게 표현하며, 
'앞에서 뺀 것을 다시 뒤로 넣는' 동작을 통해 원형 회전을 매우 직관적으로 시뮬레이션할 수 있기 때문입니다. 
(물론 연결 리스트도 가능하지만, 알고리즘 구현 관점에서는 큐를 이용한 회전 로직이 매우 간결합니다.)

Q. 큐가 순차적, 순환적 특징을 처리하는 동작 과정
큐를 사용하여 N명의 사람 중 K번째 사람을 제거하는 과정을 단계별로 설명하면 다음과 같습니다. (예: N=7, K=3)

1. 초기화 (원형 배치)
1번부터 N번까지의 사람을 순서대로 큐에 넣습니다(Enqueue).
큐 상태: [1, 2, 3, 4, 5, 6, 7] (front ... rear)

2. 순환 처리 (Rotation)
K번째 사람을 제거하기 위해서는, 그 앞에 있는 K-1명을 건너뛰어야 합니다.
큐의 맨 앞에 있는 사람(front)을 꺼내서(Dequeue), 즉시 큐의 맨 뒤로 다시 넣습니다(Enqueue). 이 과정이 원탁을 돌리는 것과 같습니다.
동작: 1번을 뒤로 보냄 → [2, 3, 4, 5, 6, 7, 1]
동작: 2번을 뒤로 보냄 → [3, 4, 5, 6, 7, 1, 2]

3. 제거 (Elimination)
이제 큐의 맨 앞에 있는 사람이 바로 K번째(3번) 사람입니다.
이 사람은 원에서 나가야 하므로, Dequeue를 수행하고 다시 넣지 않습니다(영구 제거).
동작: 3번 제거 → [4, 5, 6, 7, 1, 2] (출력: 3)

4. 반복 (Loop)
큐에 한 명이 남을 때까지 위 2번(K-1회 회전)과 3번(1회 제거) 과정을 반복합니다.
다음 순서에서는 4, 5번을 뒤로 보내고 6번을 제거하게 됩니다.
결론: 큐를 이용하면 복잡한 인덱스 계산이나 포인터 조작 없이, "K-1번 앞에서 빼서 뒤로 넣고(Rotate), 1번 뺀다(Pop)"라는 단순한 논리만으로 원형 순열 문제를 완벽하게 해결할 수 있습니다.


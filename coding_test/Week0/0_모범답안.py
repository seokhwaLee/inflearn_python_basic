# 문제 1: 최댓값 찾기 (find_max)
시간 복잡도: O(n)

분석 및 근거
해당 함수는 입력된 리스트 numbers의 모든 원소를 정확히 한 번씩 순회하며 최댓값을 갱신하는 구조를 가지고 있습니다.

max_num = numbers[0] 연산은 상수 시간 O(1)이 소요됩니다.
for num in numbers: 반복문은 리스트의 길이인 n만큼 반복 수행됩니다.
반복문 내부의 비교 연산(if num > max_num)과 대입 연산(max_num = num)은 기본 연산으로 O(1)의 시간이 걸립니다.
따라서 전체 연산 횟수는 입력 크기 n에 비례하여 선형적으로 증가하므로, 시간 복잡도는 O(n)입니다.


# 문제 2: 중복 확인 (has_duplicates)
시간 복잡도: O(n^2)

분석 및 근거
이 코드는 두 개의 중첩된 반복문(Nested Loop)을 사용하여 리스트 내의 모든 가능한 쌍(pair)을 비교합니다.

외부 반복문(i)은 0부터 n-1까지 순회합니다.
내부 반복문(j)은 i+1부터 n-1까지 순회합니다.
가장 최악의 경우(중복이 없거나 맨 마지막에 있는 경우), 비교 연산의 총 횟수는 다음과 같은 등차수열의 합으로 표현됩니다.
(n-1) + (n-2) + \dots + 1 = \frac{n(n-1)}{2}
위 식을 전개하면 \frac{1}{2}n^2 - \frac{1}{2}n이 되며, 빅오 표기법에서는 최고차항만을 고려하고 계수를 무시하므로 O(n^2)가 됩니다.


# 문제 3: 이진 탐색 (binary_search)
시간 복잡도: O(\log n)

분석 및 근거
이진 탐색은 정렬된 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 찾는 알고리즘입니다.

반복문이 한 번 실행될 때마다 mid를 기준으로 탐색 범위(right - left)가 절반(1/2)으로 줄어듭니다.
입력 크기가 n일 때, 최악의 경우 탐색이 종료될 때까지 반복하는 횟수 k는 n \times (\frac{1}{2})^k \approx 1을 만족해야 합니다.
이를 k에 대해 풀면 2^k \approx n이므로, k \approx \log_2 n이 됩니다.
따라서 탐색 공간이 선형적으로 줄어드는 것이 아니라 로그 스케일로 줄어들기 때문에 시간 복잡도는 O(\log n)입니다.


# 문제 4: in 연산의 자료구조별 성능 차이
1. target in my_list (List)
시간 복잡도: O(n)
근거 및 원리: 파이썬의 리스트(List)는 데이터를 메모리에 연속적으로 저장하는 동적 배열(Dynamic Array)입니다. 
특정 값이 존재하는지 확인하기 위해서는 첫 번째 원소부터 마지막 원소까지 순차적으로 비교하는 선형 탐색(Linear Search)을 수행해야 합니다. 
찾으려는 값이 맨 끝에 있거나 없는 최악의 경우, n개의 원소를 모두 확인해야 합니다.

2. target in my_set (Set)
시간 복잡도: O(1) (평균적인 경우)
근거 및 원리: 파이썬의 세트(Set)는 해시 테이블(Hash Table)로 구현되어 있습니다. 
특정 값 target을 찾을 때, 순차적으로 탐색하는 것이 아니라 target의 해시(Hash) 값을 계산하여 해당 데이터가 저장된 메모리 주소(버킷)로 즉시 접근합니다. 
해시 충돌이 매우 빈번하게 발생하는 극단적인 경우를 제외하면, 데이터의 개수 n과 무관하게 거의 즉시 값을 찾을 수 있습니다.


# 문제 5: 첫 번째 원소 제거 (pop) 연산의 성능 차이
1. my_list.pop(0) (List)
시간 복잡도: O(n)
근거 및 원리: 리스트는 연속된 메모리 공간을 사용하는 배열 기반 구조입니다. 
맨 앞의 원소(인덱스 0)를 제거하면, 그 자리가 비게 됩니다. 
메모리의 연속성을 유지하기 위해 뒤에 있는 나머지 n-1개의 모든 원소를 한 칸씩 앞으로 이동(Shift)시키는 작업이 필요합니다. 
따라서 리스트의 크기가 커질수록 이동시켜야 할 데이터가 많아져 연산 비용이 선형적으로 증가합니다.

2. my_deque.popleft() (Deque)
시간 복잡도: O(1)
근거 및 원리: collections.deque는 이중 연결 리스트(Doubly Linked List)(엄밀히는 블록 단위의 링크드 리스트)로 구현되어 있습니다. 
연결 리스트 구조에서는 맨 앞의 노드를 제거할 때, 단순히 헤드(Head) 포인터가 가리키는 위치만 다음 노드로 변경하면 됩니다. 
데이터를 물리적으로 이동시킬 필요 없이 연결 고리만 수정하면 되므로, 데이터의 크기 n과 관계없이 항상 일정한 속도로 처리가 가능합니다.